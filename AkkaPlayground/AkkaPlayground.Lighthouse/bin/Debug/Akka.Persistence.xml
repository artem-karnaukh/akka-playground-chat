<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka.Persistence</name>
    </assembly>
    <members>
        <member name="T:Akka.Persistence.AtLeastOnceDeliveryReceiveActor">
            <summary>
                Receive persistent actor type, that sends messages with at-least-once delivery semantics to it's destinations.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.RedeliverInterval">
            <summary>
            Interval between redelivery attempts.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.redeliver-interval'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.RedeliveryBurstLimit">
            <summary>
            Maximum number of unconfirmed messages that will be sent at each redelivery burst
            (burst frequency is half of the redelivery interval).
            If there's a lot of unconfirmed messages (e.g. if the destination is not available for a long time),
            this helps prevent an overwhelming amount of messages to be sent at once.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.redelivery-burst-limit'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.WarnAfterNumberOfUnconfirmedAttempts">
            <summary>
            After this number of delivery attempts a <see cref="T:Akka.Persistence.UnconfirmedWarning" /> message will be sent to
            <see cref="P:Akka.Actor.ActorBase.Self" />. The count is reset after restart.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.warn-after-number-of-unconfirmed-attempts'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.MaxUnconfirmedMessages">
            <summary>
            Maximum number of unconfirmed messages, that this actor is allowed to hold in the memory.
            if this number is exceeded, <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)" /> will not accept more
            messages and it will throw <see cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException" />.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.max-unconfirmed-messages'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.UnconfirmedCount">
            <summary>
            Number of messages that have not been confirmed yet.
            </summary>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object})">
            <summary>
            Send the message created with <paramref name="deliveryMessageMapper" /> function to the
            <paramref name="destination" /> actor. It will retry sending the message until the delivery is
            confirmed with <see cref="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.ConfirmDelivery(System.Int64)" />.
            Correlation between these two methods is performed by deliveryId that is provided as parameter
            to the <paramref name="deliveryMessageMapper"/> function. The deliveryId is typically passed in the message to
            the destination, which replies with a message containing the same 'deliveryId'.
            
            The 'deliveryId' is a strictly monotonically increasing sequence number without gaps.
            The same sequence is used for all destinations of the actor, i.e. when sending
            to multiple destinations the destinations will see gaps in the sequence if no translation is performed.
            
            During recovery this method will not send out the message, but it will be sent later if no matching 
            <see cref="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.ConfirmDelivery(System.Int64)" /> was performed.
            </summary>
            <exception cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException">
            Thrown when <see cref="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.UnconfirmedCount" /> is greater than or equal to <see cref="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.MaxUnconfirmedMessages" />.
            </exception>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.Deliver(Akka.Actor.ActorSelection,System.Func{System.Int64,System.Object})">
            <summary>
            Send the message created with <paramref name="deliveryMessageMapper" /> function to the
            <paramref name="destination" /> actor. It will retry sending the message until the delivery is
            confirmed with <see cref="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.ConfirmDelivery(System.Int64)" />.
            Correlation between these two methods is performed by deliveryId that is provided as parameter
            to the <paramref name="deliveryMessageMapper"/> function. The deliveryId is typically passed in the message to
            the destination, which replies with a message containing the same 'deliveryId'.
            
            The 'deliveryId' is a strictly monotonically increasing sequence number without gaps.
            The same sequence is used for all destinations of the actor, i.e. when sending
            to multiple destinations the destinations will see gaps in the sequence if no translation is performed.
            
            During recovery this method will not send out the message, but it will be sent later if no matching 
            <see cref="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.ConfirmDelivery(System.Int64)" /> was performed.
            </summary>
            <exception cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException">
            Thrown when <see cref="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.UnconfirmedCount" /> is greater than or equal to <see cref="P:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.MaxUnconfirmedMessages" />.
            </exception>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.ConfirmDelivery(System.Int64)">
            <summary>
            Call this method when a message has been confirmed by the destination,
            or to abort re-sending.
            </summary>
            <returns>True the first time the <paramref name="deliveryId"/> is confirmed, false for duplicate confirmations.</returns>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.GetDeliverySnapshot">
            <summary>
            Full state of the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySemantic"/>. It can be saved with
            <see cref="M:Akka.Persistence.Eventsourced.SaveSnapshot(System.Object)" />. During recovery the snapshot received in
            <see cref="T:Akka.Persistence.SnapshotOffer"/> should be set with <see cref="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)"/>.
            
            The <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/> contains the full delivery state,
            including unconfirmed messages. If you need a custom snapshot for other parts of the
            actor state you must also include the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>.
            It is serialized using protobuf with the ordinary Akka serialization mechanism.
            It is easiest to include the bytes of the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>
            as a blob in your custom snapshot.
            </summary>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)">
            <summary>
            If snapshot from <see cref="M:Akka.Persistence.AtLeastOnceDeliveryReceiveActor.GetDeliverySnapshot" /> was saved it will be received during recovery
            phase in a <see cref="T:Akka.Persistence.SnapshotOffer" /> message and should be set with this method.
            </summary>
        </member>
        <member name="T:Akka.Persistence.AtLeastOnceDeliverySnapshot">
            <summary>
            Snapshot of current <see cref="T:Akka.Persistence.AtLeastOnceDeliveryActor" /> state. Can be retrieved with
            <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.GetDeliverySnapshot" /> and saved with
            <see cref="M:Akka.Persistence.Eventsourced.SaveSnapshot(System.Object)" />.
            During recovery the snapshot received in <see cref="T:Akka.Persistence.SnapshotOffer" /> should be sent with
            <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)" />.
            </summary>
        </member>
        <member name="T:Akka.Persistence.UnconfirmedWarning">
            <summary>
            Message should be sent after <see cref="P:Akka.Persistence.AtLeastOnceDeliverySemantic.WarnAfterNumberOfUnconfirmedAttempts" />
            limit will is reached.
            </summary>
        </member>
        <member name="T:Akka.Persistence.UnconfirmedDelivery">
            <summary>
            Contains details about unconfirmed messages.
            It's included inside <see cref="T:Akka.Persistence.UnconfirmedWarning" /> and <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot" />.
            <see cref="!:AtLeastOnceDeliverySemantic.AfterNumberOfUnconfirmedAttempts" />
            </summary>
        </member>
        <member name="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException">
            <summary>
            This exception is thrown when the <see cref="P:Akka.Persistence.AtLeastOnceDeliverySemantic.MaxUnconfirmedMessages" /> threshold has been exceeded.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliverySemantic.RedeliverInterval">
            <summary>
            Interval between redelivery attempts.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.redeliver-interval'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliverySemantic.RedeliveryBurstLimit">
            <summary>
            Maximum number of unconfirmed messages that will be sent at each redelivery burst
            (burst frequency is half of the redelivery interval).
            If there's a lot of unconfirmed messages (e.g. if the destination is not available for a long time),
            this helps prevent an overwhelming amount of messages to be sent at once.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.redelivery-burst-limit'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliverySemantic.WarnAfterNumberOfUnconfirmedAttempts">
            <summary>
            After this number of delivery attempts a <see cref="T:Akka.Persistence.UnconfirmedWarning" /> message will be sent to
            <see cref="P:Akka.Actor.ActorBase.Self" />. The count is reset after restart.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.warn-after-number-of-unconfirmed-attempts'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliverySemantic.MaxUnconfirmedMessages">
            <summary>
            Maximum number of unconfirmed messages, that this actor is allowed to hold in the memory.
            if this number is exceeded, <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)" /> will not accept more
            messages and it will throw <see cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException" />.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.max-unconfirmed-messages'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliverySemantic.UnconfirmedCount">
            <summary>
                Number of messages, that have not been confirmed yet.
            </summary>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliverySemantic.ConfirmDelivery(System.Int64)">
            <summary>
            Call this method when a message has been confirmed by the destination,
            or to abort re-sending.
            </summary>
            <returns>True the first time the <paramref name="deliveryId"/> is confirmed, false for duplicate confirmations.</returns>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliverySemantic.GetDeliverySnapshot">
            <summary>
            Full state of the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySemantic"/>. It can be saved with
            <see cref="M:Akka.Persistence.Eventsourced.SaveSnapshot(System.Object)" />. During recovery the snapshot received in
            <see cref="T:Akka.Persistence.SnapshotOffer"/> should be set with <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)"/>.
            
            The <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/> contains the full delivery state,
            including unconfirmed messages. If you need a custom snapshot for other parts of the
            actor state you must also include the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>.
            It is serialized using protobuf with the ordinary Akka serialization mechanism.
            It is easiest to include the bytes of the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>
            as a blob in your custom snapshot.
            </summary>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliverySemantic.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)">
            <summary>
            If snapshot from <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.GetDeliverySnapshot" /> was saved it will be received during recovery
            phase in a <see cref="T:Akka.Persistence.SnapshotOffer" /> message and should be set with this method.
            </summary>
        </member>
        <member name="F:Akka.Persistence.Eventsourced._pendingStashingPersistInvocations">
            Used instead of iterating `pendingInvocations` in order to check if safe to revert to processing commands
        </member>
        <member name="F:Akka.Persistence.Eventsourced._pendingInvocations">
            Holds user-supplied callbacks for persist/persistAsync calls
        </member>
        <member name="P:Akka.Persistence.Eventsourced.PersistenceId">
            <summary>
            Id of the persistent entity for which messages should be replayed.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Eventsourced.Recovery">
            <summary>
            Called when the persistent actor is started for the first time.
            The returned <see cref="T:Akka.Persistence.Recovery"/> object defines how the actor
            will recover its persistent state behore handling the first incoming message.
            
            To skip recovery completely return <see cref="F:Akka.Persistence.Recovery.None"/>.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Eventsourced.SnapshotterId">
            <summary>
            Returns <see cref="P:Akka.Persistence.Eventsourced.PersistenceId"/>.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Eventsourced.IsRecovering">
            <summary>
            Returns true if this persistent entity is currently recovering.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Eventsourced.IsRecoveryFinished">
            <summary>
            Returns true if this persistent entity has successfully finished recovery.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Eventsourced.LastSequenceNr">
            <summary>
            Highest received sequence number so far or `0L` if this actor 
            hasn't replayed  or stored any persistent events yet.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Eventsourced.SnapshotSequenceNr">
            <summary>
            Returns <see cref="P:Akka.Persistence.Eventsourced.LastSequenceNr"/>
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.LoadSnapshot(System.String,Akka.Persistence.SnapshotSelectionCriteria,System.Int64)">
            <summary>
            Instructs the snapshot store to load the specified snapshot and send it via an
            <see cref="T:Akka.Persistence.SnapshotOffer"/> to the running <see cref="T:Akka.Persistence.PersistentActor"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.SaveSnapshot(System.Object)">
            <summary>
            Saves <paramref name="snapshot"/> of current <see cref="T:Akka.Persistence.ISnapshotter"/> state.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the success or failure of this
            via an <see cref="T:Akka.Persistence.SaveSnapshotSuccess"/> or <see cref="T:Akka.Persistence.SaveSnapshotFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.DeleteSnapshot(System.Int64)">
            <summary>
            Deletes the snapshot identified by <paramref name="sequenceNr"/>.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the status of the deletion
            via an <see cref="T:Akka.Persistence.DeleteSnapshotSuccess"/> or <see cref="T:Akka.Persistence.DeleteSnapshotFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria)">
            <summary>
            Deletes all snapshots matching <paramref name="criteria"/>.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the status of the deletion
            via an <see cref="T:Akka.Persistence.DeleteSnapshotsSuccess"/> or <see cref="T:Akka.Persistence.DeleteSnapshotsFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.ReceiveRecover(System.Object)">
            <summary> 
            Recovery handler that receives persistent events during recovery. If a state snapshot has been captured and saved, 
            this handler will receive a <see cref="T:Akka.Persistence.SnapshotOffer"/> message followed by events that are younger than offer itself.
            
            This handler must not have side-effects other than changing persistent actor state i.e. it
            should not perform actions that may fail, such as interacting with external services,
            for example.
            
            If there is a problem with recovering the state of the actor from the journal, the error
            will be logged and the actor will be stopped.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.ReceiveCommand(System.Object)">
            <summary>
            Command handler. Typically validates commands against current state - possibly by communicating with other actors.
            On successful validation, one or more events are derived from command and persisted.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})">
             <summary> 
             Asynchronously persists an <paramref name="event"/>. On successful persistence, the <paramref name="handler"/>
             is called with the persisted event. This method guarantees that no new commands will be received by a persistent actor
             between a call to <see cref="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})"/> and execution of it's handler. It also
             holds multiple persist calls per received command. Internally this is done by stashing. The stash used
             for that is an internal stash which doesn't interfere with the inherited user stash.
             
             
             An event <paramref name="handler"/> may close over eventsourced actor state and modify it. Sender of the persistent event
             is considered a sender of the corresponding command. That means one can respond to sender from within an event handler.
             
             
             Within an event handler, applications usually update persistent actor state using 
             persisted event data, notify listeners and reply to command senders.
             
            
             If persistence of an event fails, <see cref="M:Akka.Persistence.Eventsourced.OnPersistFailure(System.Exception,System.Object,System.Int64)" /> will be invoked and the actor will
             unconditionally be stopped. The reason that it cannot resume when persist fails is that it
             is unknown if the event was actually persisted or not, and therefore it is in an inconsistent
             state. Restarting on persistent failures will most likely fail anyway, since the journal
             is probably unavailable. It is better to stop the actor and after a back-off timeout start
             it again.
             </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.PersistAll``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Asynchronously persists series of <paramref name="events"/> in specified order.
            This is equivalent of multiple calls of <see cref="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})"/> calls
            with the same handler, except that events are persisted atomically with this method.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.PersistAsync``1(``0,System.Action{``0})">
            <summary> 
            Asynchronously persists an <paramref name="event"/>. On successful persistence, the <paramref name="handler"/>
            is called with the persisted event. Unlike <see cref="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})"/> method,
            this one will continue to receive incoming commands between calls and executing it's event <paramref name="handler"/>.
            
            
            This version should be used in favor of <see cref="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})"/> 
            method when throughput is more important that commands execution precedence.
            
            
            An event <paramref name="handler"/> may close over eventsourced actor state and modify it. Sender of the persistent event
            is considered a sender of the corresponding command. That means, one can respond to sender from within an event handler.
            
            
            Within an event handler, applications usually update persistent actor state using 
            persisted event data, notify listeners and reply to command senders.
            
            
            If persistence of an event fails, <see cref="M:Akka.Persistence.Eventsourced.OnPersistFailure(System.Exception,System.Object,System.Int64)" /> will be invoked and the actor will
            unconditionally be stopped. The reason that it cannot resume when persist fails is that it
            is unknown if the event was actually persisted or not, and therefore it is in an inconsistent
            state. Restarting on persistent failures will most likely fail anyway, since the journal
            is probably unavailable. It is better to stop the actor and after a back-off timeout start
            it again.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.PersistAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Asynchronously persists series of <paramref name="events"/> in specified order.
            This is equivalent of multiple calls of <see cref="M:Akka.Persistence.Eventsourced.PersistAsync``1(``0,System.Action{``0})"/> calls
            with the same handler, except that events are persisted atomically with this method.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.DeferAsync``1(``0,System.Action{``0})">
            <summary>
            Defer the <paramref name="handler"/> execution until all pending handlers have been executed. 
            Allows to define logic within the actor, which will respect the invocation-order-guarantee
            in respect to <see cref="M:Akka.Persistence.Eventsourced.PersistAsync``1(``0,System.Action{``0})"/> calls.
            That is, if <see cref="M:Akka.Persistence.Eventsourced.PersistAsync``1(``0,System.Action{``0})"/> was invoked before
            <see cref="M:Akka.Persistence.Eventsourced.DeferAsync``1(``0,System.Action{``0})"/>, the corresponding handlers will be
            invoked in the same order as they were registered in.
            
            This call will NOT result in <paramref name="evt"/> being persisted, use
            <see cref="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})"/> or
            <see cref="M:Akka.Persistence.Eventsourced.PersistAsync``1(``0,System.Action{``0})"/> instead if the given
            <paramref name="evt"/> should be possible to replay.
            
            If there are no pending persist handler calls, the <paramref name="handler"/> will be called immediately.
            
            If persistence of an earlier event fails, the persistent actor will stop, and the
            <paramref name="handler"/> will not be run.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.OnReplaySuccess">
            <summary>
            Called whenever a message replay succeeds.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.OnRecoveryFailure(System.Exception,System.Object)">
            <summary>
            Called whenever a message replay fails. By default it log the errors.
            </summary>
            <param name="reason">Reason of failure</param>
            <param name="message">Message that caused a failure</param>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.OnPersistFailure(System.Exception,System.Object,System.Int64)">
             <summary>
             Called when persist fails. By default it logs the error.
             Subclass may override to customize logging and for example send negative
             acknowledgment to sender.
            
             The actor is always stopped after this method has been invoked.
            
             Note that the event may or may not have been saved, depending on the type of
             failure.
             </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.OnPersistRejected(System.Exception,System.Object,System.Int64)">
            <summary>
            Called when the journal rejected <see cref="!:PersistentActor.Persist&lt;TEvent&gt;(TEvent,Action&lt;TEvent&gt;)"/> of an event.
            The event was not stored. By default this method logs the problem as a warning, and the actor continues.
            The callback handler that was passed to the <see cref="!:PersistentActor.Persist&lt;TEvent&gt;(TEvent,Action&lt;TEvent&gt;)"/>
            method will not be invoked.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.RecoveryStarted(System.Int64)">
            <summary>
            Processes a loaded snapshot, if any. A loaded snapshot is offered with a <see cref="T:Akka.Persistence.SnapshotOffer"/> 
            message to the actor's <see cref="M:Akka.Persistence.Eventsourced.ReceiveRecover(System.Object)"/>. Then initiates a message replay, either starting 
            from the loaded snapshot or from scratch, and switches to <see cref="!:ReplayStarted"/> state. 
            All incoming messages are stashed.
            </summary>
            <param name="maxReplays">Maximum number of messages to replay</param>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.Recovering(Akka.Actor.Receive)">
            <summary>
            Processes replayed messages, if any. The actor's <see cref="M:Akka.Persistence.Eventsourced.ReceiveRecover(System.Object)"/> is invoked with the replayed events.
            
            If replay succeeds it got highest stored sequence number response from the journal and then switches
            to <see cref="M:Akka.Persistence.Eventsourced.ProcessingCommands"/> state.
            If replay succeeds the <see cref="M:Akka.Persistence.Eventsourced.OnReplaySuccess"/> callback method is called, otherwise
            <see cref="M:Akka.Persistence.Eventsourced.OnRecoveryFailure(System.Exception,System.Object)"/>.
            
            All incoming messages are stashed.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.ProcessingCommands">
            <summary>
            If event persistence is pending after processing a command, event persistence 
            is triggered and the state changes to <see cref="M:Akka.Persistence.Eventsourced.PersistingEvents"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Eventsourced.PersistingEvents">
            <summary>
            Remains until pending events are persisted and then changes state to <see cref="M:Akka.Persistence.Eventsourced.ProcessingCommands"/>.
            Only events to be persisted are processed. All other messages are stashed internally.
            </summary>
        </member>
        <member name="T:Akka.Persistence.AtLeastOnceDeliveryActor">
            <summary>
            Persistent actor type that sends messages with at-least-once delivery semantics to destinations.
            It takes care of re-sending messages when they haven't been confirmed withing expected timeout.
            Use the <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)" /> method to send a message to a destination. Call the
            <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.ConfirmDelivery(System.Int64)" />
            method when destination has replied with a confirmation message.
            
            At-least-once delivery implies that the original message send order is not always retained
            and the destination may receive duplicate messages due to possible resends.
            
            The interval between redelivery attempts can be defined with <see cref="P:Akka.Persistence.AtLeastOnceDeliverySemantic.RedeliverInterval" />.
            After a number of delivery attempts a <see cref="T:Akka.Persistence.UnconfirmedWarning" /> message will be sent to <see cref="P:Akka.Actor.ActorBase.Self" />.
            The re-sending will continue, but you may choose <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.ConfirmDelivery(System.Int64)" /> to cancel re-sending.
            
            This actor type has a state consisting of unconfirmed messages and a sequence number. It does not store this state
            itself. You must persist events corresponding to the <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)"/> and
            <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.ConfirmDelivery(System.Int64)"/> invocations from your <see cref="T:Akka.Persistence.PersistentActor"/> so that
            the state can be restored by calling the same methods during the recovery phase of the <see cref="T:Akka.Persistence.PersistentActor"/>.
            Sometimes these events can be derived from other business level events, and sometimes you must create separate events.
            During recovery calls to <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)"/> will not send out the message, but it will be sent
            later if no matching <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.ConfirmDelivery(System.Int64)"/> was performed.
            
            Support for snapshot is provided by <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.GetDeliverySnapshot"/> and
            <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)"/>. The <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/> contains
            the full delivery state, including unconfirmed messages. If you need a custom snapshot for other parts of the
            actor state you must also include the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>. It is serialized using protobuf
            with the ordinary Akka serialization mechanism. It is easiest to include the bytes of the
            <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/> as a blob in your custom snapshot.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryActor.RedeliverInterval">
            <summary>
            Interval between redelivery attempts.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.redeliver-interval'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryActor.RedeliveryBurstLimit">
            <summary>
            Maximum number of unconfirmed messages that will be sent at each redelivery burst
            (burst frequency is half of the redelivery interval).
            If there's a lot of unconfirmed messages (e.g. if the destination is not available for a long time),
            this helps prevent an overwhelming amount of messages to be sent at once.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.redelivery-burst-limit'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryActor.WarnAfterNumberOfUnconfirmedAttempts">
            <summary>
            After this number of delivery attempts a <see cref="T:Akka.Persistence.UnconfirmedWarning" /> message will be sent to
            <see cref="P:Akka.Actor.ActorBase.Self" />. The count is reset after restart.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.warn-after-number-of-unconfirmed-attempts'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryActor.MaxUnconfirmedMessages">
            <summary>
            Maximum number of unconfirmed messages, that this actor is allowed to hold in the memory.
            if this number is exceeded, <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)" /> will not accept more
            messages and it will throw <see cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException" />.
            
            The default value can be configure with the 'akka.persistence.at-least-once-delivery.max-unconfirmed-messages'
            configuration key. This method can be overridden by implementation classes to return
            non-default values.
            </summary>
        </member>
        <member name="P:Akka.Persistence.AtLeastOnceDeliveryActor.UnconfirmedCount">
            <summary>
            Number of messages that have not been confirmed yet.
            </summary>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryActor.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object})">
            <summary>
            Send the message created with <paramref name="deliveryMessageMapper" /> function to the
            <paramref name="destination" /> actor. It will retry sending the message until the delivery is
            confirmed with <see cref="M:Akka.Persistence.AtLeastOnceDeliveryActor.ConfirmDelivery(System.Int64)" />.
            Correlation between these two methods is performed by deliveryId that is provided as parameter
            to the <paramref name="deliveryMessageMapper"/> function. The deliveryId is typically passed in the message to
            the destination, which replies with a message containing the same 'deliveryId'.
            
            The 'deliveryId' is a strictly monotonically increasing sequence number without gaps.
            The same sequence is used for all destinations of the actor, i.e. when sending
            to multiple destinations the destinations will see gaps in the sequence if no translation is performed.
            
            During recovery this method will not send out the message, but it will be sent later if no matching 
            <see cref="M:Akka.Persistence.AtLeastOnceDeliveryActor.ConfirmDelivery(System.Int64)" /> was performed.
            </summary>
            <exception cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException">
            Thrown when <see cref="P:Akka.Persistence.AtLeastOnceDeliveryActor.UnconfirmedCount" /> is greater than or equal to <see cref="P:Akka.Persistence.AtLeastOnceDeliveryActor.MaxUnconfirmedMessages" />.
            </exception>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryActor.Deliver(Akka.Actor.ActorSelection,System.Func{System.Int64,System.Object})">
            <summary>
            Send the message created with <paramref name="deliveryMessageMapper" /> function to the
            <paramref name="destination" /> actor. It will retry sending the message until the delivery is
            confirmed with <see cref="M:Akka.Persistence.AtLeastOnceDeliveryActor.ConfirmDelivery(System.Int64)" />.
            Correlation between these two methods is performed by deliveryId that is provided as parameter
            to the <paramref name="deliveryMessageMapper"/> function. The deliveryId is typically passed in the message to
            the destination, which replies with a message containing the same 'deliveryId'.
            
            The 'deliveryId' is a strictly monotonically increasing sequence number without gaps.
            The same sequence is used for all destinations of the actor, i.e. when sending
            to multiple destinations the destinations will see gaps in the sequence if no translation is performed.
            
            During recovery this method will not send out the message, but it will be sent later if no matching 
            <see cref="M:Akka.Persistence.AtLeastOnceDeliveryActor.ConfirmDelivery(System.Int64)" /> was performed.
            </summary>
            <exception cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException">
            Thrown when <see cref="P:Akka.Persistence.AtLeastOnceDeliveryActor.UnconfirmedCount" /> is greater than or equal to <see cref="P:Akka.Persistence.AtLeastOnceDeliveryActor.MaxUnconfirmedMessages" />.
            </exception>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryActor.ConfirmDelivery(System.Int64)">
            <summary>
            Call this method when a message has been confirmed by the destination,
            or to abort re-sending.
            </summary>
            <returns>True the first time the <paramref name="deliveryId"/> is confirmed, false for duplicate confirmations.</returns>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryActor.GetDeliverySnapshot">
            <summary>
            Full state of the <see cref="T:Akka.Persistence.AtLeastOnceDeliveryActor"/>. It can be saved with
            <see cref="M:Akka.Persistence.Eventsourced.SaveSnapshot(System.Object)" />. During recovery the snapshot received in
            <see cref="T:Akka.Persistence.SnapshotOffer"/> should be set with <see cref="M:Akka.Persistence.AtLeastOnceDeliveryActor.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)"/>.
            
            The <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/> contains the full delivery state,
            including unconfirmed messages. If you need a custom snapshot for other parts of the
            actor state you must also include the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>.
            It is serialized using protobuf with the ordinary Akka serialization mechanism.
            It is easiest to include the bytes of the <see cref="T:Akka.Persistence.AtLeastOnceDeliverySnapshot"/>
            as a blob in your custom snapshot.
            </summary>
        </member>
        <member name="M:Akka.Persistence.AtLeastOnceDeliveryActor.SetDeliverySnapshot(Akka.Persistence.AtLeastOnceDeliverySnapshot)">
            <summary>
            If snapshot from <see cref="M:Akka.Persistence.AtLeastOnceDeliveryActor.GetDeliverySnapshot" /> was saved it will be received during recovery
            phase in a <see cref="T:Akka.Persistence.SnapshotOffer" /> message and should be set with this method.
            </summary>
        </member>
        <member name="T:Akka.Persistence.StashingHandlerInvocation">
            <summary>
            Forces actor to stash incoming commands until all invocations are handled.
            </summary>
        </member>
        <member name="T:Akka.Persistence.AsyncHandlerInvocation">
            <summary>
            Unlike <see cref="T:Akka.Persistence.StashingHandlerInvocation"/> this one does not force actor to stash commands.
            Originates from <see cref="M:Akka.Persistence.Eventsourced.PersistAsync``1(``0,System.Action{``0})"/> 
            or <see cref="M:Akka.Persistence.Eventsourced.DeferAsync``1(``0,System.Action{``0})"/> method calls.
            </summary>
        </member>
        <member name="M:Akka.Persistence.LinkedListExtensions.Pop``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Removes first element from the list and returns it or returns default value if list was empty.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Fsm.PersistentFSM`3">
            <summary>
                Finite state machine (FSM) persistent actor.
            </summary>
            <typeparam name="TState">The state name type</typeparam>
            <typeparam name="TData">The state data type</typeparam>
            <typeparam name="TEvent">The event data type</typeparam>
        </member>
        <member name="F:Akka.Persistence.Fsm.PersistentFSMBase`3._stateFunctions">
            <summary>
                State definitions
            </summary>
        </member>
        <member name="F:Akka.Persistence.Fsm.PersistentFSMBase`3._timers">
            <summary>
                Timer handling
            </summary>
        </member>
        <member name="F:Akka.Persistence.Fsm.PersistentFSMBase`3._transitionEvent">
            <summary>
                Transition handling
            </summary>
        </member>
        <member name="F:Akka.Persistence.Fsm.PersistentFSMBase`3._currentState">
            <summary>
                FSM state data and current timeout handling
            </summary>
            a
        </member>
        <member name="F:Akka.Persistence.Fsm.PersistentFSMBase`3._terminateEvent">
            <summary>
                Termination handling
            </summary>
        </member>
        <member name="F:Akka.Persistence.Fsm.PersistentFSMBase`3.DebugEvent">
            <summary>
                Can be set to enable debugging on certain actions taken by the FSM
            </summary>
        </member>
        <member name="P:Akka.Persistence.Fsm.PersistentFSMBase`3.StateName">
            <summary>
                Current state name
            </summary>
        </member>
        <member name="P:Akka.Persistence.Fsm.PersistentFSMBase`3.StateData">
            <summary>
                Current state data
            </summary>
        </member>
        <member name="P:Akka.Persistence.Fsm.PersistentFSMBase`3.NextStateData">
            <summary>
                Return next state data (available in <see cref="M:Akka.Persistence.Fsm.PersistentFSMBase`3.OnTransition(Akka.Persistence.Fsm.PersistentFSMBase{`0,`1,`2}.TransitionHandler)" /> handlers)
            </summary>
        </member>
        <member name="P:Akka.Persistence.Fsm.PersistentFSMBase`3.HandleEventDefault">
            <summary>
                Unhandled event handler
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.When(`0,Akka.Persistence.Fsm.PersistentFSMBase{`0,`1,`2}.StateFunction,System.Nullable{System.TimeSpan})">
            <summary>
                Insert a new <see cref="T:Akka.Persistence.Fsm.PersistentFSMBase`3.StateFunction" /> at the end of the processing chain for the
                given state. If the stateTimeout parameter is set, entering this state without a
                differing explicit timeout setting will trigger a <see cref="T:Akka.Actor.FSMBase.StateTimeout" />.
            </summary>
            <param name="stateName">designator for the state</param>
            <param name="func">delegate describing this state's response to input</param>
            <param name="timeout">default timeout for this state</param>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.StartWith(`0,`1,System.Nullable{System.TimeSpan})">
            <summary>
                Sets the initial state for this FSM. Call this method from the constructor before the <see cref="M:Akka.Persistence.Fsm.PersistentFSMBase`3.Initialize" />
                method.
                If different state is needed after a restart this method, followed by <see cref="M:Akka.Persistence.Fsm.PersistentFSMBase`3.Initialize" />, can be used in the
                actor
                life cycle hooks <see cref="M:Akka.Actor.ActorBase.PreStart" /> and <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)" />.
            </summary>
            <param name="stateName">Initial state designator.</param>
            <param name="stateData">Initial state data.</param>
            <param name="timeout">State timeout for the initial state, overriding the default timeout for that state.</param>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.GoTo(`0)">
            <summary>
                Produce transition to other state. Return this from a state function
                in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.GoTo(`0,`1)">
            <summary>
                Produce transition to other state. Return this from a state function
                in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <param name="stateData">Data for next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.Stay">
            <summary>
                Produce "empty" transition descriptor. Return this from a state function
                when no state change is to be effected.
            </summary>
            <returns>Descriptor for staying in the current state.</returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.Stop">
            <summary>
                Produce change descriptor to stop this FSM actor with <see cref="T:Akka.Actor.FSMBase.Reason" /> <see cref="T:Akka.Actor.FSMBase.Normal" />
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.Stop(Akka.Actor.FSMBase.Reason)">
            <summary>
                Produce change descriptor to stop this FSM actor with the specified <see cref="T:Akka.Actor.FSMBase.Reason" />.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.SetTimer(System.String,System.Object,System.TimeSpan,System.Boolean)">
            <summary>
                Schedule named timer to deliver message after given delay, possibly repeating.
                Any existing timer with the same name will automatically be canceled before adding
                the new timer.
            </summary>
            <param name="name">identifier to be used with <see cref="M:Akka.Persistence.Fsm.PersistentFSMBase`3.CancelTimer(System.String)" />.</param>
            <param name="msg">message to be delivered</param>
            <param name="timeout">delay of first message delivery and between subsequent messages.</param>
            <param name="repeat">send once if false, scheduleAtFixedRate if true</param>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.CancelTimer(System.String)">
            <summary>
                Cancel a named <see cref="T:System.Threading.Timer" />, ensuring that the message is not subsequently delivered (no
                race.)
            </summary>
            <param name="name">The name of the timer to cancel.</param>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.IsTimerActive(System.String)">
            <summary>
                Determines whether the named timer is still active. Returns true
                unless the timer does not exist, has previously been cancelled, or
                if it was a single-shot timer whose message was already received.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.SetStateTimeout(`0,System.Nullable{System.TimeSpan})">
            <summary>
                Set the state timeout explicitly. This method can be safely used from
                within a state handler.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.OnTransition(Akka.Persistence.Fsm.PersistentFSMBase{`0,`1,`2}.TransitionHandler)">
            <summary>
                Set handler which is called upon each state transition, i.e. not when
                staying in the same state.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})">
            <summary>
                Set the handler which is called upon termination of this FSM actor. Calling this
                method again will overwrite the previous contents.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.WhenUnhandled(Akka.Persistence.Fsm.PersistentFSMBase{`0,`1,`2}.StateFunction)">
            <summary>
                Set handler which is called upon reception of unhandled FSM messages. Calling
                this method again will overwrite the previous contents.
            </summary>
            <param name="stateFunction"></param>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.Initialize">
            <summary>
                Verify the existence of initial state and setup timers. This should be the
                last call within the constructor or <see cref="M:Akka.Actor.ActorBase.PreStart" /> and
                <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)" />.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.OrElse(Akka.Persistence.Fsm.PersistentFSMBase{`0,`1,`2}.StateFunction,Akka.Persistence.Fsm.PersistentFSMBase{`0,`1,`2}.StateFunction)">
            <summary>
                C# port of Scala's orElse method for partial function chaining.
                See http://scalachina.com/api/scala/PartialFunction.html
            </summary>
            <param name="original">The original <see cref="T:Akka.Persistence.Fsm.PersistentFSMBase`3.StateFunction" /> to be called</param>
            <param name="fallback">The <see cref="T:Akka.Persistence.Fsm.PersistentFSMBase`3.StateFunction" /> to be called if <paramref name="original" /> returns null</param>
            <returns>
                A <see cref="T:Akka.Persistence.Fsm.PersistentFSMBase`3.StateFunction" /> which combines both the results of <paramref name="original" /> and
                <paramref name="fallback" />
            </returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.PostStop">
            <summary>
                Call the <see cref="!:PersistentFSMBase.OnTermination" /> hook if you want to retain this behavior.
                When overriding make sure to call base.PostStop();
                Please note that this method is called by default from <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)" /> so
                override that one if <see cref="!:PersistentFSMBase.OnTermination" /> shall not be called during restart.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.LogTermination(Akka.Actor.FSMBase.Reason)">
            <summary>
                By default, <see cref="T:Akka.Actor.Failure" /> is logged at error level and other
                reason types are not logged. It is possible to override this behavior.
            </summary>
            <param name="reason"></param>
        </member>
        <member name="T:Akka.Persistence.Fsm.PersistentFSMBase`3.StateTimeout">
            <summary>
                Used in the event of a timeout between transitions
            </summary>
        </member>
        <member name="T:Akka.Persistence.Fsm.PersistentFSMBase`3.State`3">
            <summary>
                This captures all of the managed state of the <see cref="T:Akka.Persistence.Fsm.PersistentFSM`3" />: the state name,
                the state data, possibly custom timeout, stop reason, and replies accumulated while
                processing the last message.
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
            <typeparam name="TE">The event of the state</typeparam>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.State`3.Applying(Akka.Util.ILinearSeq{`5})">
            <summary>
                Specify domain events to be applied when transitioning to the new state.
            </summary>
            <param name="events"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.State`3.Applying(`5)">
            <summary>
                Specify domain event to be applied when transitioning to the new state.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.State`3.AndThen(System.Action{`4})">
            <summary>
                Register a handler to be triggered after the state has been persisted successfully
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.State`3.Using(`4)">
            <summary>
                Modify state transition descriptor with new state data. The data will be set
                when transitioning to the new state.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Fsm.PersistentFSMBase`3.State`3.WithStopReason(Akka.Actor.FSMBase.Reason)">
            <summary>
                INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Persistence.InternalExtensions.EnqueueMessageFirst(Akka.Actor.IActorContext,System.Object)">
            <summary>
            Enqueues provided <paramref name="message"/> at the beginning of the internal actor cell mailbox message queue.
            Requires current actor to use unbounded deque-based message queue. It will fail otherwise.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Journal.IEventAdapter">
             <summary>
             <para>An <see cref="T:Akka.Persistence.Journal.IEventAdapter"/> is both a <see cref="T:Akka.Persistence.Journal.IWriteEventAdapter"/> and a <see cref="T:Akka.Persistence.Journal.IReadEventAdapter"/>.
             Facility to convert from and to specialised data models, as may be required by specialized persistence Journals.</para>
            
             <para>Typical use cases include (but are not limited to):</para>
             <para>- adding metadata, a.k.a. "tagging" - by wrapping objects into tagged counterparts</para>
             <para>- manually converting to the Journals storage format, such as JSON, BSON or any specialised binary format</para>
             <para>- adapting incoming events in any way before persisting them by the journal</para>
             </summary>
        </member>
        <member name="T:Akka.Persistence.Journal.IWriteEventAdapter">
             <summary>
             <para>Facility to convert to specialised data models, as may be required by specialized persistence Journals.</para>
            
             <para>Typical use cases include (but are not limited to):</para>
             <para>- adding metadata, a.k.a. "tagging" - by wrapping objects into tagged counterparts</para>
             <para>- manually converting to the Journals storage format, such as JSON, BSON or any specialised binary format</para>
             <para>- splitting up large events into sequences of smaller ones</para>
             </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.IWriteEventAdapter.Manifest(System.Object)">
            <summary>
            Return the manifest (type hint) that will be provided in the <see cref="!:FromJournal"/> method.
            Use empty string if not needed.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.IWriteEventAdapter.ToJournal(System.Object)">
             <summary>
             <para>Convert domain event to journal event type.</para>
            
             <para>Some journal may require a specific type to be returned to them,
             for example if a primary key has to be associated with each event then a journal
             may require adapters to return "EventWithPrimaryKey(event, key)".</para>
            
             <para>The <see cref="M:Akka.Persistence.Journal.IWriteEventAdapter.ToJournal(System.Object)"/> adaptation must be an 1-to-1 transformation.
             It is not allowed to drop incoming events during the `toJournal` adaptation.</para>
             </summary>
             <param name="evt">the application-side domain event to be adapted to the journal model</param>
             <returns>the adapted event object, possibly the same object if no adaptation was performed</returns>
        </member>
        <member name="T:Akka.Persistence.Journal.IReadEventAdapter">
             <summary>
             <para>Facility to convert from specialised data models, as may be required by specialized persistence Journals.</para>
            
             <para>Typical use cases include (but are not limited to):</para>
             <para>- extracting events from "envelopes"</para>
             <para>- manually converting to the Journals storage format, such as JSON, BSON or any specialised binary format</para>
             <para>- adapting incoming events from a "data model" to the "domain model"</para>
             </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.IReadEventAdapter.FromJournal(System.Object,System.String)">
             <summary>
             <para>Convert an event from its journal model to the application's domain model.</para>
            
             <para>One event may be adapter into multiple(or none) events which should be delivered to the <see cref="T:Akka.Persistence.PersistentActor"/>.
             Use the specialised <see cref="M:Akka.Persistence.Journal.EventSequence.Single(System.Object)"/> method to emit exactly one event,
             or <see cref="F:Akka.Persistence.Journal.EventSequence.Empty"/> in case the adapter is not handling this event. Multiple <see cref="T:Akka.Persistence.Journal.IEventAdapter"/> instances are
             applied in order as defined in configuration and their emitted event seqs are concatenated and delivered in order
             to the PersistentActor.</para>
             </summary>
             <param name="evt">event to be adapted before delivering to the PersistentActor</param>
             <param name="manifest">optionally provided manifest(type hint) in case the Adapter has stored one for this event. Use empty string if none.</param>
             <returns>sequence containing the adapted events (possibly zero) which will be delivered to the PersistentActor</returns>
        </member>
        <member name="T:Akka.Persistence.Journal.PersistencePluginProxyExtension">
            <summary>
            <see cref="T:Akka.Persistence.Journal.PersistencePluginProxyExtension"/> is an <see cref="T:Akka.Actor.IExtension"/> that enables initialization
            of the <see cref="T:Akka.Persistence.Journal.PersistencePluginProxy"/> via configuration, without requiring any code changes or the
            creation of any actors.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Journal.ReplayFilter">
            <summary>
            Detect corrupt event stream during replay. It uses the <see cref="P:Akka.Persistence.IPersistentRepresentation.WriterGuid"/> and the
            <see cref="P:Akka.Persistence.IPersistentRepresentation.SequenceNr"/> in the replayed events to find events emitted by overlapping writers.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.IAsyncRecovery.ReplayMessagesAsync(Akka.Actor.IActorContext,System.String,System.Int64,System.Int64,System.Int64,System.Action{Akka.Persistence.IPersistentRepresentation})">
            <summary>
            Asynchronously replays persistent messages. Implementations replay
            a message by calling <paramref name="recoveryCallback"/>. The returned task must be completed
            when all messages (matching the sequence number bounds) have been replayed.
            The task must be completed with a failure if any of the persistent messages
            could not be replayed.
            
            The <paramref name="toSequenceNr"/> is the lowest of what was returned by
            <see cref="M:Akka.Persistence.Journal.IAsyncRecovery.ReadHighestSequenceNrAsync(System.String,System.Int64)"/> and what the user specified as recovery
            <see cref="T:Akka.Persistence.Recovery"/> parameter.
            This does imply that this call is always preceded by reading the highest sequence number
            for the given <paramref name="persistenceId"/>.
            
            This call is NOT protected with a circuit-breaker because it may take a long time
            to replay all events. The plugin implementation itself must protect against an
            unresponsive backend store and make sure that the returned <see cref="T:System.Threading.Tasks.Task"/>
            is completed with success or failure within reasonable time. It is not allowed to
            ignore completing the <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <param name="persistenceId">Persistent actor identifier</param>
            <param name="fromSequenceNr">Inclusive sequence number where replay should start</param>
            <param name="toSequenceNr">Inclusive sequence number where replay should end</param>
            <param name="max">Maximum number of messages to be replayed</param>
            <param name="recoveryCallback">Called to replay a message, may be called from any thread.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.Journal.IAsyncRecovery.ReadHighestSequenceNrAsync(System.String,System.Int64)">
            <summary>
            Asynchronously reads the highest stored sequence number for provided <paramref name="persistenceId"/>.
            The persistent actor will use the highest sequence number after recovery as the starting point when
            persisting new events.
            This sequence number is also used as `toSequenceNr` in subsequent calls to
            <see cref="M:Akka.Persistence.Journal.IAsyncRecovery.ReplayMessagesAsync(Akka.Actor.IActorContext,System.String,System.Int64,System.Int64,System.Int64,System.Action{Akka.Persistence.IPersistentRepresentation})"/> unless the user has specified a lower `toSequenceNr`.
            Journal must maintain the highest sequence number and never decrease it.
            
            This call is protected with a circuit-breaker.
            
            Please also not that requests for the highest sequence number may be made concurrently
            to writes executing for the same <paramref name="persistenceId"/>, in particular it is
            possible that a restarting actor tries to recover before its outstanding writes have completed.
            </summary>
            <param name="persistenceId">Persistent actor identifier</param>
            <param name="fromSequenceNr">Hint where to start searching for the highest sequence number.
            When a persistent actor is recovering this <paramref name="fromSequenceNr"/> will the the sequence
            number of the used snapshot, or `0L` if no snapshot is used.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.Journal.AsyncWriteJournal.WriteMessagesAsync(System.Collections.Generic.IEnumerable{Akka.Persistence.AtomicWrite})">
            <summary>
            Plugin API: asynchronously writes a batch of persistent messages to the
            journal.
            
            The batch is only for performance reasons, i.e. all messages don't have to be written
            atomically. Higher throughput can typically be achieved by using batch inserts of many
            records compared to inserting records one-by-one, but this aspect depends on the
            underlying data store and a journal implementation can implement it as efficient as
            possible. Journals should aim to persist events in-order for a given `persistenceId`
            as otherwise in case of a failure, the persistent state may be end up being inconsistent.
            
            Each <see cref="T:Akka.Persistence.AtomicWrite"/> message contains the single <see cref="T:Akka.Persistence.Persistent"/>
            that corresponds to the event that was passed to the 
            <see cref="!:PersistentActor.Persist&lt;TEvent&gt;(TEvent,Action&lt;TEvent&gt;)"/> method of the
            <see cref="T:Akka.Persistence.PersistentActor" />, or it contains several <see cref="T:Akka.Persistence.Persistent"/>
            that correspond to the events that were passed to the
            <see cref="!:PersistentActor.PersistAll&lt;TEvent&gt;(IEnumerable&lt;TEvent&gt;,Action&lt;TEvent&gt;)"/>
            method of the <see cref="T:Akka.Persistence.PersistentActor"/>. All <see cref="T:Akka.Persistence.Persistent"/> of the
            <see cref="T:Akka.Persistence.AtomicWrite"/> must be written to the data store atomically, i.e. all or none must
            be stored. If the journal (data store) cannot support atomic writes of multiple
            events it should reject such writes with a <see cref="T:System.NotSupportedException"/>
            describing the issue. This limitation should also be documented by the journal plugin.
            
            If there are failures when storing any of the messages in the batch the returned
            <see cref="T:System.Threading.Tasks.Task"/> must be completed with failure. The <see cref="T:System.Threading.Tasks.Task"/> must only be completed with
            success when all messages in the batch have been confirmed to be stored successfully,
            i.e. they will be readable, and visible, in a subsequent replay. If there is
            uncertainty about if the messages were stored or not the <see cref="T:System.Threading.Tasks.Task"/> must be completed
            with failure.
            
            Data store connection problems must be signaled by completing the <see cref="T:System.Threading.Tasks.Task"/> with
            failure.
            
            The journal can also signal that it rejects individual messages (<see cref="T:Akka.Persistence.AtomicWrite"/>) by
            the returned <see cref="T:System.Threading.Tasks.Task"/>. It is possible but not mandatory to reduce
            number of allocations by returning null for the happy path,
            i.e. when no messages are rejected. Otherwise the returned list must have as many elements
            as the input <paramref name="messages"/>. Each result element signals if the corresponding
            <see cref="T:Akka.Persistence.AtomicWrite"/> is rejected or not, with an exception describing the problem. Rejecting
            a message means it was not stored, i.e. it must not be included in a later replay.
            Rejecting a message is typically done before attempting to store it, e.g. because of
            serialization error.
            
            Data store connection problems must not be signaled as rejections.
            
            It is possible but not mandatory to reduce number of allocations by returning
            null for the happy path, i.e. when no messages are rejected.
            
            Calls to this method are serialized by the enclosing journal actor. If you spawn
            work in asyncronous tasks it is alright that they complete the futures in any order,
            but the actual writes for a specific persistenceId should be serialized to avoid
            issues such as events of a later write are visible to consumers (query side, or replay)
            before the events of an earlier write are visible.
            A <see cref="T:Akka.Persistence.PersistentActor"/> will not send a new <see cref="T:Akka.Persistence.WriteMessages"/> request before
            the previous one has been completed.
            
            Please not that the <see cref="P:Akka.Persistence.IPersistentRepresentation.Sender"/> of the contained
            <see cref="T:Akka.Persistence.Persistent"/> objects has been nulled out (i.e. set to <see cref="F:Akka.Actor.ActorRefs.NoSender"/>
            in order to not use space in the journal for a sender reference that will likely be obsolete
            during replay.
            
            Please also note that requests for the highest sequence number may be made concurrently
            to this call executing for the same `persistenceId`, in particular it is possible that
            a restarting actor tries to recover before its outstanding writes have completed.
            In the latter case it is highly desirable to defer reading the highest sequence number
            until all outstanding writes have completed, otherwise the <see cref="T:Akka.Persistence.PersistentActor"/>
            may reuse sequence numbers.
            
            This call is protected with a circuit-breaker.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.AsyncWriteJournal.DeleteMessagesToAsync(System.String,System.Int64)">
            <summary>
            Asynchronously deletes all persistent messages up to inclusive <paramref name="toSequenceNr"/>
            bound.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.AsyncWriteJournal.ReceivePluginInternal(System.Object)">
            <summary>
            Allows plugin implementers to use <see cref="M:Akka.Actor.PipeToSupport.PipeTo``1(System.Threading.Tasks.Task{``0},Akka.Actor.ICanTell,Akka.Actor.IActorRef,System.Func{``0,System.Object},System.Func{System.Exception,System.Object})"/> <see cref="P:Akka.Actor.ActorBase.Self"/>
            and handle additional messages for implementing advanced features
            </summary>
        </member>
        <member name="T:Akka.Persistence.Journal.AsyncReplayTimeoutException">
            <summary>
            This exception is thrown when the replay inactivity exceeds a specified timeout.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.AsyncReplayTimeoutException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Persistence.Journal.AsyncReplayTimeoutException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Journal.AsyncReplayTimeoutException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Persistence.Journal.AsyncReplayTimeoutException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Persistence.Journal.AsyncReplayTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Persistence.Journal.AsyncReplayTimeoutException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Persistence.Journal.AsyncWriteProxy">
            <summary>
            A journal that delegates actual storage to a target actor. For testing only.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Journal.MemoryJournal">
            <summary>
            In-memory journal for testing purposes.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Recovery">
            <summary>
            Recovery mode configuration object to be return in <see cref="!:PersistentActor.get_Recovery()"/>
            
            By default recovers from latest snashot replays through to the last available event (last sequenceNr).
            
            Recovery will start from a snapshot if the persistent actor has previously saved one or more snapshots
            and at least one of these snapshots matches the specified <see cref="P:Akka.Persistence.Recovery.FromSnapshot"/> criteria.
            Otherwise, recovery will start from scratch by replaying all stored events.
            
            If recovery starts from a snapshot, the <see cref="T:Akka.Persistence.PersistentActor"/> is offered that snapshot with a
            <see cref="T:Akka.Persistence.SnapshotOffer"/> message, followed by replayed messages, if any, that are younger than the snapshot, up to the
            specified upper sequence number bound (<see cref="P:Akka.Persistence.Recovery.ToSequenceNr"/>).
            </summary>
        </member>
        <member name="P:Akka.Persistence.Recovery.FromSnapshot">
            <summary>
            Criteria for selecting a saved snapshot from which recovery should start. Default is latest (= youngest) snapshot.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Recovery.ToSequenceNr">
            <summary>
            Upper, inclusive sequence number bound for recovery. Default is no upper bound.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Recovery.ReplayMax">
            <summary>
            Maximum number of messages to replay. Default is no limit.
            </summary>
        </member>
        <member name="T:Akka.Persistence.IStashOverflowStrategy">
            <summary>
            This defines how to handle the current received message which failed to stash, when the size
            of the Stash exceeding the capacity of the Stash.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DiscardToDeadLetterStrategy">
            <summary>
            Discard the message to <see cref="T:Akka.Actor.DeadLetterActorRef"/>
            </summary>
        </member>
        <member name="T:Akka.Persistence.ThrowOverflowExceptionStrategy">
            <summary>
            Throw <see cref="T:Akka.Actor.StashOverflowException"/>, hence the persistent actor will start recovery
            if guarded by default supervisor strategy.
            Be careful if used together with <see cref="M:Akka.Persistence.Eventsourced.Persist``1(``0,System.Action{``0})"/>
            or <see cref="M:Akka.Persistence.Eventsourced.PersistAll``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})"/>
            or has many messages needed to replay.
            </summary>
        </member>
        <member name="T:Akka.Persistence.ReplyToStrategy">
            <summary>
            Reply to sender with predefined response, and discard the received message silently.
            </summary>
        </member>
        <member name="P:Akka.Persistence.ReplyToStrategy.Response">
            <summary>
            The message replying to sender with
            </summary>
        </member>
        <member name="T:Akka.Persistence.IStashOverflowStrategyConfigurator">
            <summary>
            Implement this interface in order to configure the <see cref="T:Akka.Persistence.IStashOverflowStrategy"/>
            for the internal stash of the persistent actor.
            An instance of this class must be instantiable using a no-args constructor.
            </summary>
        </member>
        <member name="T:Akka.Persistence.PersistentActor">
            <summary>
            Persistent actor - can be used to implement command or eventsourcing.
            </summary>
        </member>
        <member name="T:Akka.Persistence.UntypedPersistentActor">
            <summary>
            Persistent actor - can be used to implement command or eventsourcing.
            </summary>
        </member>
        <member name="M:Akka.Persistence.UntypedPersistentActor.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Persistence.UntypedPersistentActor.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="!:IUntypedActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Persistence.UntypedPersistentActor.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="!:IUntypedActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Persistence.ReceivePersistentActor.PrepareConfigureMessageHandlers">
            <summary>
            Creates and pushes a new MatchBuilder
            </summary>
        </member>
        <member name="M:Akka.Persistence.ReceivePersistentActor.Become(System.Action)">
            <summary>
            Changes the actor's command behavior and replaces the current receive command handler with the specified handler.
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Persistence.ReceivePersistentActor.BecomeStacked(System.Action)">
            <summary>
            Changes the actor's command behavior and replaces the current receive command handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Persistence.ReceivePersistentActor.BecomeStacked(System.Action)"/>
            is matched with a call to <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="configure">Configures the new handler by calling the different Command overloads.</param>
        </member>
        <member name="T:Akka.Persistence.PersistentView">
            <summary>
            A view replicates the persistent message stream of a <see cref="T:Akka.Persistence.PersistentActor"/>. Implementation classes receive
            the message stream directly from the Journal. These messages can be processed to update internal state
            in order to maintain an (eventual consistent) view of the state of the corresponding persistent actor. A
            persistent view can also run on a different node, provided that a replicated journal is used.
            
            Implementation classes refer to a persistent actors' message stream by implementing `persistenceId`
            with the corresponding (shared) identifier value.
            
            Views can also store snapshots of internal state by calling [[autoUpdate]]. The snapshots of a view
            are independent of those of the referenced persistent actor. During recovery, a saved snapshot is offered
            to the view with a <see cref="T:Akka.Persistence.SnapshotOffer"/> message, followed by replayed messages, if any, that are younger
            than the snapshot. Default is to offer the latest saved snapshot.
            
            By default, a view automatically updates itself with an interval returned by `autoUpdateInterval`.
            This method can be overridden by implementation classes to define a view instance-specific update
            interval. The default update interval for all views of an actor system can be configured with the
            `akka.persistence.view.auto-update-interval` configuration key. Applications may trigger additional
            view updates by sending the view <see cref="T:Akka.Persistence.Update"/> requests. See also methods
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.RecoveryStarted(System.Int64)">
            <summary>
            Processes a loaded snapshot, if any. A loaded snapshot is offered with a <see cref="T:Akka.Persistence.SnapshotOffer"/>
            message to the actor's <see cref="!:PersistentView.Receive"/> method. Then initiates a message replay, either 
            starting from the loaded snapshot or from scratch, and switches to <see cref="M:Akka.Persistence.PersistentView.ReplayStarted(System.Boolean)"/> state.
            All incoming messages are stashed.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.ReplayStarted(System.Boolean)">
            <summary>
            Processes replayed message, if any. The actor's <see cref="!:PersistentView.Receive"/> is invoked 
            with the replayed events.
            
            If replay succeeds it got highest stored sequence number response from the journal and
            then switche it switches to <see cref="M:Akka.Persistence.PersistentView.Idle"/> state.
            
            
            If replay succeeds the <see cref="!:OnReplaySuccess"/> callback method is called, otherwise
            <see cref="M:Akka.Persistence.PersistentView.OnReplayError(System.Exception)"/> is called and remaining replay events are consumed (ignored).
            
            All incoming messages are stashed when <paramref name="shouldAwait"/> is true.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.OnReplayComplete">
            <summary>
            Switches to <see cref="M:Akka.Persistence.PersistentView.Idle"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.IgnoreRemainingReplay(System.Exception)">
            <summary>
            Consumes remaining replayed messages and then throws the exception.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.Idle">
            <summary>
            When receiving an <see cref="T:Akka.Persistence.Update"/> event, switches to <see cref="M:Akka.Persistence.PersistentView.ReplayStarted(System.Boolean)"/> state
            and triggers an incremental message replay. For any other message invokes actor default behavior.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Akka.Persistence.PersistentView.ViewId">
            <summary>
            Used as identifier for snapshots performed by this <see cref="T:Akka.Persistence.PersistentView"/>. This allows the View to keep 
            separate snapshots of data than the <see cref="T:Akka.Persistence.PersistentActor"/> originating the message stream.
            
            The usual case is to have a different identifiers for <see cref="P:Akka.Persistence.PersistentView.ViewId"/> and <see cref="P:Akka.Persistence.PersistentView.PersistenceId"/>.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.PersistenceId">
            <summary>
            Id of the persistent entity for which messages should be replayed.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.SnapshotterId">
            <summary>
            Gets the <see cref="P:Akka.Persistence.PersistentView.ViewId"/>.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.IsPersistent">
            <summary>
            If true, the currently processed message was persisted - it sent from the <see cref="P:Akka.Persistence.PersistentView.Journal"/>.
            If false, the currently processed message comes from another actor ('/user/*' path).
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.IsAutoUpdate">
            <summary>
            If true, this view will update itself automatically within an interval specified by <see cref="P:Akka.Persistence.PersistentView.AutoUpdateInterval"/>.
            If false, application must update this view explicitly with <see cref="T:Akka.Persistence.Update"/> requests.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.AutoUpdateInterval">
            <summary>
            Time interval to automatic updates. Used only when <see cref="P:Akka.Persistence.PersistentView.IsAutoUpdate"/> value is true.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.AutoUpdateReplayMax">
            <summary>
            The maximum number of messages to replay per update.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.LastSequenceNr">
            <summary>
            Highest received sequence number so far or 0 it none persistent event has been replayed yet.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.SnapshotSequenceNr">
            <summary>
            Gets last sequence number.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistentView.Recovery">
            <summary>
            Called when the persistent view is started for the first time.
            The returned <see cref="T:Akka.Persistence.Recovery"/> object defines how the actor
            will recover its persistent state behore handling the first incoming message.
            
            To skip recovery completely return <see cref="F:Akka.Persistence.Recovery.None"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.OnReplayError(System.Exception)">
            <summary>
            Called whenever a message replay fails. By default it logs the error.
            Subclass may override to customize logging.
            The <see cref="T:Akka.Persistence.PersistentView"/> will not stop or throw exception due to this.
            It will try again on next update.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.Persistence.PersistentView.LoadSnapshot(System.String,Akka.Persistence.SnapshotSelectionCriteria,System.Int64)">
            <summary>
            Instructs the snapshot store to load the specified snapshot and send it via an
            <see cref="T:Akka.Persistence.SnapshotOffer"/> to the running <see cref="T:Akka.Persistence.PersistentActor"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.SaveSnapshot(System.Object)">
            <summary>
            Saves <paramref name="snapshot"/> of current <see cref="T:Akka.Persistence.ISnapshotter"/> state.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the success or failure of this
            via an <see cref="T:Akka.Persistence.SaveSnapshotSuccess"/> or <see cref="T:Akka.Persistence.SaveSnapshotFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.DeleteSnapshot(System.Int64)">
            <summary>
            Deletes the snapshot identified by <paramref name="sequenceNr"/>.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the status of the deletion
            via an <see cref="T:Akka.Persistence.DeleteSnapshotSuccess"/> or <see cref="T:Akka.Persistence.DeleteSnapshotFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistentView.DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria)">
            <summary>
            Deletes all snapshots matching <paramref name="criteria"/>.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the status of the deletion
            via an <see cref="T:Akka.Persistence.DeleteSnapshotsSuccess"/> or <see cref="T:Akka.Persistence.DeleteSnapshotsFailure"/> message.
            </summary>
        </member>
        <member name="T:Akka.Persistence.IPersistenceMessage">
            <summary>
            Marker interface for internal persistence extension messages.
            
            Helps persistence plugin developers to differentiate
            internal persistence extension messages from their custom plugin messages.
            
            Journal messages need not be serialization verified as the Journal Actor
            should always be a local Actor (and serialization is performed by plugins).
            One notable exception to this is the shared journal used for testing.
            </summary>
        </member>
        <member name="T:Akka.Persistence.ISnapshotter">
            <summary>
            Snapshot API on top of the internal snapshot protocol.
            </summary>
        </member>
        <member name="P:Akka.Persistence.ISnapshotter.SnapshotterId">
            <summary>
            Snapshotter id.
            </summary>
        </member>
        <member name="P:Akka.Persistence.ISnapshotter.SnapshotSequenceNr">
            <summary>
            Incrementable sequence number to use when taking a snapshot.
            </summary>
        </member>
        <member name="M:Akka.Persistence.ISnapshotter.LoadSnapshot(System.String,Akka.Persistence.SnapshotSelectionCriteria,System.Int64)">
            <summary>
            Instructs the snapshot store to load the specified snapshot and send it via an
            <see cref="T:Akka.Persistence.SnapshotOffer"/> to the running <see cref="T:Akka.Persistence.PersistentActor"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.ISnapshotter.SaveSnapshot(System.Object)">
            <summary>
            Saves <paramref name="snapshot"/> of current <see cref="T:Akka.Persistence.ISnapshotter"/> state.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the success or failure of this
            via an <see cref="T:Akka.Persistence.SaveSnapshotSuccess"/> or <see cref="T:Akka.Persistence.SaveSnapshotFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.ISnapshotter.DeleteSnapshot(System.Int64)">
            <summary>
            Deletes the snapshot identified by <paramref name="sequenceNr"/>.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the status of the deletion
            via an <see cref="T:Akka.Persistence.DeleteSnapshotSuccess"/> or <see cref="T:Akka.Persistence.DeleteSnapshotFailure"/> message.
            </summary>
        </member>
        <member name="M:Akka.Persistence.ISnapshotter.DeleteSnapshots(Akka.Persistence.SnapshotSelectionCriteria)">
            <summary>
            Deletes all snapshots matching <paramref name="criteria"/>.
            
            The <see cref="T:Akka.Persistence.PersistentActor"/> will be notified about the status of the deletion
            via an <see cref="T:Akka.Persistence.DeleteSnapshotsSuccess"/> or <see cref="T:Akka.Persistence.DeleteSnapshotsFailure"/> message.
            </summary>
        </member>
        <member name="T:Akka.Persistence.IJournalMessage">
            <summary>
            Marker interface for internal journal messages
            </summary>
        </member>
        <member name="T:Akka.Persistence.IJournalRequest">
            <summary>
            Internal journal command
            </summary>
        </member>
        <member name="T:Akka.Persistence.IJournalResponse">
            <summary>
            Internal journal acknowledgement
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteMessagesFailure">
            <summary>
            Reply message to failed <see cref="!:DeleteMessages"/> request.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteMessagesTo">
            <summary>
            Request to delete all persistent messages with sequence numbers up to `toSequenceNr` (inclusive).  
            </summary>
        </member>
        <member name="T:Akka.Persistence.WriteMessagesSuccessful">
            <summary>
            Reply message to a successful <see cref="T:Akka.Persistence.WriteMessages"/> request. This reply is sent 
            to the requestor before all subsequent <see cref="T:Akka.Persistence.WriteMessageSuccess"/> replies.
            </summary>
        </member>
        <member name="T:Akka.Persistence.WriteMessagesFailed">
            <summary>
            Reply message to a failed <see cref="T:Akka.Persistence.WriteMessages"/> request. This reply is sent 
            to the requestor before all subsequent <see cref="T:Akka.Persistence.WriteMessageFailure"/> replies.
            </summary>
        </member>
        <member name="T:Akka.Persistence.WriteMessageSuccess">
            <summary>
            Reply message to a successful <see cref="T:Akka.Persistence.WriteMessages"/> request. For each contained 
            <see cref="T:Akka.Persistence.IPersistentRepresentation"/> message in the request, a separate reply is sent to the requestor.
            </summary>
        </member>
        <member name="F:Akka.Persistence.WriteMessageSuccess.Persistent">
            <summary>
            Successfully written message.
            </summary>
        </member>
        <member name="T:Akka.Persistence.WriteMessageRejected">
            <summary>
            Reply message to a rejected <see cref="T:Akka.Persistence.WriteMessages"/> request. The write of this message was rejected
            before it was stored, e.g. because it could not be serialized. For each contained 
            <see cref="T:Akka.Persistence.IPersistentRepresentation"/> message in the request, a separate reply is sent to the requestor.
            </summary>
        </member>
        <member name="F:Akka.Persistence.WriteMessageRejected.Persistent">
            <summary>
            Message failed to be written.
            </summary>
        </member>
        <member name="F:Akka.Persistence.WriteMessageRejected.Cause">
            <summary>
            Failure cause.
            </summary>
        </member>
        <member name="T:Akka.Persistence.WriteMessageFailure">
            <summary>
            Reply message to a failed <see cref="T:Akka.Persistence.WriteMessages"/> request. For each contained 
            <see cref="T:Akka.Persistence.IPersistentRepresentation"/> message in the request, a separate reply is sent to the requestor.
            </summary>
        </member>
        <member name="F:Akka.Persistence.WriteMessageFailure.Persistent">
            <summary>
            Message failed to be written.
            </summary>
        </member>
        <member name="F:Akka.Persistence.WriteMessageFailure.Cause">
            <summary>
            Failure cause.
            </summary>
        </member>
        <member name="T:Akka.Persistence.LoopMessageSuccess">
            <summary>
            Reply message to a <see cref="T:Akka.Persistence.WriteMessages"/> with a non-persistent message.
            </summary>
        </member>
        <member name="F:Akka.Persistence.LoopMessageSuccess.Message">
            <summary>
            A looped message.
            </summary>
        </member>
        <member name="T:Akka.Persistence.ReplayMessages">
            <summary>
            Request to replay messages to the <see cref="F:Akka.Persistence.ReplayMessages.PersistentActor"/>.
            </summary>
        </member>
        <member name="F:Akka.Persistence.ReplayMessages.FromSequenceNr">
            <summary>
            Inclusive lower sequence number bound where a replay should start.
            </summary>
        </member>
        <member name="F:Akka.Persistence.ReplayMessages.ToSequenceNr">
            <summary>
            Inclusive upper sequence number bound where a replay should end.
            </summary>
        </member>
        <member name="F:Akka.Persistence.ReplayMessages.Max">
            <summary>
            Maximum number of messages to be replayed.
            </summary>
        </member>
        <member name="F:Akka.Persistence.ReplayMessages.PersistenceId">
            <summary>
            Requesting persistent actor identifier.
            </summary>
        </member>
        <member name="F:Akka.Persistence.ReplayMessages.PersistentActor">
            <summary>
            Requesting persistent actor.
            </summary>
        </member>
        <member name="T:Akka.Persistence.ReplayedMessage">
            <summary>
            Reply message to a <see cref="T:Akka.Persistence.ReplayMessages"/> request. A separate reply is sent to the requestor for each replayed message.
            </summary>
        </member>
        <member name="T:Akka.Persistence.RecoverySuccess">
            <summary>
            Reply message to a successful <see cref="T:Akka.Persistence.ReplayMessages"/> request. This reply is sent 
            to the requestor after all <see cref="T:Akka.Persistence.ReplayedMessage"/> have been sent (if any).
            
            It includes the highest stored sequence number of a given persistent actor.
            Note that the replay might have been limited to a lower sequence number.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistenceExtension.AdaptersFor(System.String)">
            <summary>
            Returns an <see cref="T:Akka.Persistence.Journal.EventAdapters"/> object which serves as a per-journal collection of bound event adapters. 
            If no adapters are registered for a given journal the EventAdapters object will simply return the identity adapter for each 
            class, otherwise the most specific adapter matching a given class will be returned.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistenceExtension.AdaptersFor(Akka.Actor.IActorRef)">
            <summary>
            Looks up <see cref="T:Akka.Persistence.Journal.EventAdapters"/> by journal plugin's ActorRef.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistenceExtension.JournalConfigFor(System.String)">
            <summary>
            Returns the plugin config identified by <paramref name="journalPluginId"/>.
            When empty, looks in `akka.persistence.journal.plugin` to find the configuration entry path.
            When configured, uses <paramref name="journalPluginId"/> as absolute path to the journal configuration entry.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistenceExtension.ConfigFor(Akka.Actor.IActorRef)">
            <summary>
            Looks up the plugin config by plugin's ActorRef.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistenceExtension.JournalFor(System.String)">
            <summary>
            Returns a journal plugin actor identified by <paramref name="journalPluginId"/>.
            When empty, looks in `akka.persistence.journal.plugin` to find configuration entry path.
            When configured, uses <paramref name="journalPluginId"/> as absolute path to the journal configuration entry.
            Configuration entry must contain few required fields, such as `class`. See `persistence.conf`.
            </summary>
        </member>
        <member name="M:Akka.Persistence.PersistenceExtension.SnapshotStoreFor(System.String)">
            <summary>
            Returns a snapshot store plugin actor identified by <paramref name="snapshotPluginId"/>. 
            When empty, looks in `akka.persistence.snapshot-store.plugin` to find configuration entry path.
            When configured, uses <paramref name="snapshotPluginId"/> as absolute path to the snapshot store configuration entry.
            Configuration entry must contain few required fields, such as `class`. See `persistence.conf`.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Persistence">
            <summary>
            Persistence extension.
            </summary>
        </member>
        <member name="T:Akka.Persistence.PersistenceSettings">
            <summary>
            Persistence configuration.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings.RedeliverInterval">
            <summary>
                Interval between redelivery attempts.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings.MaxUnconfirmedMessages">
            <summary>
                Maximum number of unconfirmed messages, that this actor is allowed to hold in the memory. When this
                number is exceed, <see cref="M:Akka.Persistence.AtLeastOnceDeliverySemantic.Deliver(Akka.Actor.ActorPath,System.Func{System.Int64,System.Object},System.Boolean)" /> will throw
                <see cref="T:Akka.Persistence.MaxUnconfirmedMessagesExceededException" />
                instead of accepting messages.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings.WarnAfterNumberOfUnconfirmedAttempts">
            <summary>
                After this number of delivery attempts a <see cref="T:Akka.Persistence.UnconfirmedWarning" /> message will be sent to
                <see cref="P:Akka.Actor.ActorBase.Self" />.
                The count is reset after restart.
            </summary>
        </member>
        <member name="P:Akka.Persistence.PersistenceSettings.AtLeastOnceDeliverySettings.RedeliveryBurstLimit">
            <summary>
                Maximum number of unconfirmed messages that will be sent at each redelivery burst. This is to help to
                prevent overflowing amount of messages to be sent at once, for eg. when destination cannot be reached for a long
                time.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistenceRecovery.Recovery">
            <summary>
            Called when the persistent actor is started for the first time.
            The returned <see cref="T:Akka.Persistence.Recovery"/> object defines how the actor
            will recover its persistent state behore handling the first incoming message.
            
            To skip recovery completely return <see cref="F:Akka.Persistence.Recovery.None"/>.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistenceStash.InternalStashOverflowStrategy">
            <summary>
            The returned <see cref="T:Akka.Persistence.IStashOverflowStrategy"/> object determines how to handle the message
            failed to stash when the internal Stash capacity exceeded.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IWithPersistenceId.PersistenceId">
            <summary>
            Identifier of the persistent identity for which messages should be replayed.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentIdentity.PersistenceId">
            <summary>
            Identifier of the persistent identity for which messages should be replayed.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentIdentity.JournalPluginId">
            <summary>
            Configuration identifier of the journal plugin servicing current persistent actor or view.
            When empty, looks in [akka.persistence.journal.plugin] to find configuration entry path.
            Otherwise uses string value as an absolute path to the journal configuration entry.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentIdentity.SnapshotPluginId">
            <summary>
            Configuration identifier of the snapshot store plugin servicing current persistent actor or view.
            When empty, looks in [akka.persistence.snapshot-store.plugin] to find configuration entry path.
            Otherwise uses string value as an absolute path to the snapshot store configuration entry.
            </summary>
        </member>
        <member name="T:Akka.Persistence.IPersistentEnvelope">
            <summary>
            Internal API
            
            Marks messages which can then be resequenced by <see cref="T:Akka.Persistence.Journal.AsyncWriteJournal"/>.
            
            In essence it is either an <see cref="T:Akka.Persistence.NonPersistentMessage"/> or <see cref="T:Akka.Persistence.AtomicWrite"/>
            </summary>
        </member>
        <member name="T:Akka.Persistence.NonPersistentMessage">
            <summary>
            Message which can be resequenced by <see cref="T:Akka.Persistence.Journal.AsyncWriteJournal"/>, but will not be persisted.
            </summary>
        </member>
        <member name="T:Akka.Persistence.IPersistentRepresentation">
            <summary>
            Representation of a persistent message in the journal plugin API.
            
            <see cref="T:Akka.Persistence.Journal.AsyncWriteJournal"/>
            <see cref="T:Akka.Persistence.Journal.IAsyncRecovery"/>
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.Payload">
            <summary>
            This persistent message's payload.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.Manifest">
            <summary>
            Returns the persistent payload's manifest if available.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.PersistenceId">
            <summary>
            Persistent id that journals a persistent message.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.SequenceNr">
            <summary>
            Sequence number of this persistent message.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.WriterGuid">
            <summary>
            Unique identifier of the writing persistent actor.
            Used to detect anomalies with overlapping writes from multiple
            persistent actors, which can result in inconsistent replays.
            </summary>
        </member>
        <member name="M:Akka.Persistence.IPersistentRepresentation.WithPayload(System.Object)">
            <summary>
            Creates a new persistent message with the specified <paramref name="payload"/>.
            </summary>
        </member>
        <member name="M:Akka.Persistence.IPersistentRepresentation.WithManifest(System.String)">
            <summary>
            Creates a new persistent message with the specified <paramref name="manifest"/>.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.IsDeleted">
            <summary>
            Not used in new records stored with Akka.net v1.5 and above, but
            old records may have this as `true` if
            it was a non-permanent delete.
            </summary>
        </member>
        <member name="P:Akka.Persistence.IPersistentRepresentation.Sender">
            <summary>
            Sender of this message
            </summary>
        </member>
        <member name="M:Akka.Persistence.IPersistentRepresentation.Update(System.Int64,System.String,System.Boolean,Akka.Actor.IActorRef,System.String)">
            <summary>
            Creates a new deep copy of this message.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Serialization.Snapshot">
            <summary>
            Wrapper for snapshot data.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Serialization.SnapshotSerializer.ToBinary(System.Object)">
            <summary>
            Serializes a <see cref="T:Akka.Persistence.Serialization.Snapshot"/>. Delegates serialization of snapshot data to a matching
            <see cref="T:Akka.Serialization.Serializer"/>
            </summary>
        </member>
        <member name="M:Akka.Persistence.Serialization.SnapshotSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a <see cref="T:Akka.Persistence.Serialization.Snapshot"/>. Delegates deserialization of snapshot data to a matching
            <see cref="T:Akka.Serialization.Serializer"/>
            </summary>
        </member>
        <member name="T:Akka.Persistence.ISnapshotMessage">
            <summary>
            Marker interface for internal snapshot messages
            </summary>
        </member>
        <member name="T:Akka.Persistence.ISnapshotRequest">
            <summary>
            Internal snapshot command
            </summary>
        </member>
        <member name="T:Akka.Persistence.ISnapshotResponse">
            <summary>
            Internal snapshot acknowledgement
            </summary>
        </member>
        <member name="F:Akka.Persistence.SnapshotMetadata.PersistenceId">
            <summary>
            Id of the persistent actor, from which the snapshot was taken.
            </summary>
        </member>
        <member name="F:Akka.Persistence.SnapshotMetadata.SequenceNr">
            <summary>
            Sequence number at which a snapshot was taken.
            </summary>
        </member>
        <member name="F:Akka.Persistence.SnapshotMetadata.Timestamp">
            <summary>
            Time at which the snapshot was saved.
            </summary>
        </member>
        <member name="T:Akka.Persistence.SaveSnapshotSuccess">
            <summary>
            Sent to <see cref="T:Akka.Persistence.PersistentActor"/> after successful saving of a snapshot.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteSnapshotSuccess">
            <summary>
            Sent to <see cref="T:Akka.Persistence.PersistentActor"/> after successful deletion of a snapshot.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteSnapshotsSuccess">
            <summary>
            Sent to <see cref="T:Akka.Persistence.PersistentActor"/> after successful deletion of a specified range of snapshots.
            </summary>
        </member>
        <member name="T:Akka.Persistence.SaveSnapshotFailure">
            <summary>
            Sent to <see cref="T:Akka.Persistence.PersistentActor"/> after failed saving a snapshot.
            </summary>
        </member>
        <member name="F:Akka.Persistence.SaveSnapshotFailure.Metadata">
            <summary>
            Snapshot metadata.
            </summary>
        </member>
        <member name="F:Akka.Persistence.SaveSnapshotFailure.Cause">
            <summary>
            A failure cause.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteSnapshotFailure">
            <summary>
            Sent to <see cref="T:Akka.Persistence.PersistentActor"/> after failed deletion of a snapshot.
            </summary>
        </member>
        <member name="F:Akka.Persistence.DeleteSnapshotFailure.Metadata">
            <summary>
            Snapshot metadata.
            </summary>
        </member>
        <member name="F:Akka.Persistence.DeleteSnapshotFailure.Cause">
            <summary>
            A failure cause.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteSnapshotsFailure">
            <summary>
            Sent to <see cref="T:Akka.Persistence.PersistentActor"/> after failed deletion of a range of snapshots.
            </summary>
        </member>
        <member name="F:Akka.Persistence.DeleteSnapshotsFailure.Criteria">
            <summary>
            Snapshot metadata.
            </summary>
        </member>
        <member name="F:Akka.Persistence.DeleteSnapshotsFailure.Cause">
            <summary>
            A failure cause.
            </summary>
        </member>
        <member name="T:Akka.Persistence.SnapshotOffer">
            <summary>
            Offers a <see cref="T:Akka.Persistence.PersistentActor"/> a previously saved snapshot during recovery.
            This offer is received before any further replayed messages.
            </summary>
        </member>
        <member name="T:Akka.Persistence.SnapshotSelectionCriteria">
            <summary>
            Selection criteria for loading and deleting a snapshots.
            </summary>
        </member>
        <member name="F:Akka.Persistence.SnapshotSelectionCriteria.MaxSequenceNr">
            <summary>
            Upper bound for a selected snapshot's sequence number.
            </summary>
        </member>
        <member name="F:Akka.Persistence.SnapshotSelectionCriteria.MaxTimeStamp">
            <summary>
            Upper bound for a selected snapshot's timestamp.
            </summary>
        </member>
        <member name="T:Akka.Persistence.SelectedSnapshot">
            <summary>
            A selected snapshot matching <see cref="T:Akka.Persistence.SnapshotSelectionCriteria"/>.
            </summary>
        </member>
        <member name="T:Akka.Persistence.LoadSnapshot">
            <summary>
            Instructs a snapshot store to load the snapshot.
            </summary>
        </member>
        <member name="F:Akka.Persistence.LoadSnapshot.PersistenceId">
            <summary>
            Persistent actor identifier.
            </summary>
        </member>
        <member name="F:Akka.Persistence.LoadSnapshot.Criteria">
            <summary>
            Criteria for selecting snapshot, from which the recovery should start.
            </summary>
        </member>
        <member name="F:Akka.Persistence.LoadSnapshot.ToSequenceNr">
            <summary>
            Upper, inclusive sequence number bound for recovery.
            </summary>
        </member>
        <member name="T:Akka.Persistence.LoadSnapshotResult">
            <summary>
            Response to a <see cref="T:Akka.Persistence.LoadSnapshot"/> message.
            </summary>
        </member>
        <member name="F:Akka.Persistence.LoadSnapshotResult.Snapshot">
            <summary>
            Loaded snapshot or null if none provided.
            </summary>
        </member>
        <member name="T:Akka.Persistence.SaveSnapshot">
            <summary>
            Instructs a snapshot store to save a snapshot.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteSnapshot">
            <summary>
            Instructs a snapshot store to delete a snapshot.
            </summary>
        </member>
        <member name="T:Akka.Persistence.DeleteSnapshots">
            <summary>
            Instructs a snapshot store to delete all snapshots that match provided criteria.
            </summary>
        </member>
        <member name="T:Akka.Persistence.Snapshot.NoSnapshotStore">
            <summary>
            Used as a default snapshot-store in case no other store was configured.
            
            If a <see cref="T:Akka.Persistence.PersistentActor"/> calls the <see cref="!:PersistentActor.SaveSnapshot(object)"/> method,
            and at the same time does not configure a specific snapshot-store to be used *and* no default snapshot-store
            is available, then the <see cref="T:Akka.Persistence.Snapshot.NoSnapshotStore"/> will be used to signal a snapshot store failure.
            </summary>
        </member>
        <member name="M:Akka.Persistence.Snapshot.SnapshotStore.LoadAsync(System.String,Akka.Persistence.SnapshotSelectionCriteria)">
            <summary>
            Asynchronously loads a snapshot.
            
            This call is protected with a circuit-breaker
            </summary>
        </member>
        <member name="M:Akka.Persistence.Snapshot.SnapshotStore.SaveAsync(Akka.Persistence.SnapshotMetadata,System.Object)">
            <summary>
            Asynchronously saves a snapshot.
            
            This call is protected with a circuit-breaker
            </summary>
        </member>
        <member name="M:Akka.Persistence.Snapshot.SnapshotStore.DeleteAsync(Akka.Persistence.SnapshotMetadata)">
            <summary>
            Deletes the snapshot identified by <paramref name="metadata"/>.
            
            This call is protected with a circuit-breaker
            </summary>
        </member>
        <member name="M:Akka.Persistence.Snapshot.SnapshotStore.DeleteAsync(System.String,Akka.Persistence.SnapshotSelectionCriteria)">
            <summary>
            Deletes all snapshots matching provided <paramref name="criteria"/>.
            
            This call is protected with a circuit-breaker
            </summary>
        </member>
        <member name="M:Akka.Persistence.Snapshot.SnapshotStore.ReceivePluginInternal(System.Object)">
            <summary>
            Allows plugin implementers to use <see cref="M:Akka.Actor.PipeToSupport.PipeTo``1(System.Threading.Tasks.Task{``0},Akka.Actor.ICanTell,Akka.Actor.IActorRef,System.Func{``0,System.Object},System.Func{System.Exception,System.Object})"/> <see cref="P:Akka.Actor.ActorBase.Self"/>
            and handle additional messages for implementing advanced features
            </summary>
        </member>
        <member name="T:Akka.Persistence.Update">
            <summary>
            Instructs a <see cref="T:Akka.Persistence.PersistentView"/> to update itself. This will run a single incremental message replay 
            with all messages from the corresponding persistent id's journal that have not yet been consumed by the view.  
            To update a view with messages that have been written after handling this request, another <see cref="T:Akka.Persistence.Update"/> 
            request must be sent to the view.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Update.IsAwait">
            <summary>
            If `true`, processing of further messages sent to the view will be delayed 
            until the incremental message replay, triggered by this update request, completes. 
            If `false`, any message sent to the view may interleave with replayed <see cref="T:Akka.Persistence.Persistent"/> message stream.
            </summary>
        </member>
        <member name="P:Akka.Persistence.Update.ReplayMax">
            <summary>
            Maximum number of messages to replay when handling this update request. Defaults to <see cref="F:System.Int64.MaxValue"/> (i.e. no limit).
            </summary>
        </member>
    </members>
</doc>
